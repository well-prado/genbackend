import OpenAI from 'openai';
import type { GeneratedNode, GeneratorConfig } from '../types';
import fs from 'fs';
import path from 'path';
import { logger } from '../utils/logger';

/**
 * Generate TypeScript code for a node based on its description
 */
export async function generateNodeCode(
  nodeInfo: any,
  config: GeneratorConfig
): Promise<GeneratedNode | null> {
  try {
    if (!nodeInfo || !nodeInfo.name || !nodeInfo.type) {
      logger.error('Invalid node info provided');
      return null;
    }

    // Initialize OpenAI client
    if (!config.openaiApiKey) {
      logger.error('OpenAI API key is required');
      return null;
    }

    const openai = new OpenAI({
      apiKey: config.openaiApiKey
    });

    // Create a filename for the node
    const nodeName = nodeInfo.name.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
    const fileName = `${nodeName}.ts`;
    const filePath = `nodes/${fileName}`;

    // Create the system prompt
    const systemPrompt = `You are an expert TypeScript developer specializing in creating nodes for nanoservice-ts.
Your task is to generate the TypeScript code for a node based on the following specifications:

Node name: ${nodeInfo.name}
Node type: ${nodeInfo.type}
Node description: ${nodeInfo.description || 'No description provided'}

Inputs: ${JSON.stringify(nodeInfo.inputs || [])}
Outputs: ${JSON.stringify(nodeInfo.outputs || [])}

A nanoservice-ts node is a class that extends NanoService and implements a handle method.
The handle method takes two parameters:
1. A Context object that contains the current state and request information
2. An inputs object that contains the inputs to the node

The handle method should return a NanoServiceResponse object.

Please generate a complete TypeScript file with imports, class definition, input schema, and handle method implementation.
Use best practices for error handling and type safety.

The node should be useful in a real-world scenario and include comprehensive comments.`;

    // Log what we're doing
    logger.log(`Generating node code for: ${nodeInfo.name}`);

    // Make the API call to OpenAI
    const completion = await openai.chat.completions.create({
      model: config.model || 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: systemPrompt
        }
      ],
      temperature: 0.3,
      max_tokens: 2500
    });

    const content = completion.choices[0]?.message.content;

    if (!content) {
      logger.error('No content in OpenAI response');
      return null;
    }

    // Extract the code from the response (assuming it might come with markdown)
    const codeMatch = content.match(/```(?:typescript|ts)([\s\S]*?)```/) ||
      content.match(/```([\s\S]*?)```/) ||
      [null, content];

    let code = codeMatch[1] ? codeMatch[1].trim() : content.trim();

    // Add file comment
    code = `/**
 * Generated node: ${nodeInfo.name}
 * Description: ${nodeInfo.description || 'No description provided'}
 * Type: ${nodeInfo.type}
 * Generated by Generative Backend Builder
 */

${code}`;

    // Return the generated node
    return {
      name: nodeInfo.name,
      type: nodeInfo.type,
      code,
      filepath: filePath
    };
  } catch (error) {
    logger.error('Error in generateNodeCode:', error);
    return null;
  }
}

/**
 * Generate a DataProcessor node (a common type of node)
 */
export async function generateDataProcessorNode(
  config: GeneratorConfig,
  name: string,
  description: string
): Promise<GeneratedNode | null> {
  const nodeInfo = {
    name,
    type: 'data-processor',
    description,
    inputs: [
      {
        name: 'data',
        type: 'object',
        description: 'The data to be processed'
      }
    ],
    outputs: [
      {
        name: 'processedData',
        type: 'object',
        description: 'The processed data'
      }
    ]
  };

  return generateNodeCode(nodeInfo, config);
}

/**
 * Generate a DatabaseAccessor node (for database operations)
 */
export async function generateDatabaseNode(
  config: GeneratorConfig,
  name: string,
  description: string,
  databaseType: 'mongodb' | 'postgresql' | 'mysql' = 'mongodb'
): Promise<GeneratedNode | null> {
  const nodeInfo = {
    name,
    type: 'database',
    description,
    inputs: [
      {
        name: 'operation',
        type: 'string',
        description: 'The database operation to perform (find, insert, update, delete)'
      },
      {
        name: 'collection',
        type: 'string',
        description: 'The collection or table to operate on'
      },
      {
        name: 'data',
        type: 'object',
        description: 'The data for the operation'
      }
    ],
    outputs: [
      {
        name: 'result',
        type: 'object',
        description: 'The result of the database operation'
      }
    ],
    databaseType
  };

  return generateNodeCode(nodeInfo, config);
} 