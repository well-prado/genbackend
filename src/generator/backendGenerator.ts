import fs from 'fs';
import path from 'path';
import { nanoid } from 'nanoid';
import {
  type GeneratedBackend,
  type GeneratedNode,
  type GeneratedWorkflow,
  type GeneratedEndpoint,
  type GeneratorConfig,
  type GenerationResult,
  type OpenAPISpec
} from '../types';
import { generateOpenAPISpec } from './openApiGenerator';
import { updateGeneratedBackend } from '../server';
import { generateNodeCode } from './nodeGenerator';
import { generateWorkflowCode } from './workflowGenerator';
import { parsePrompt } from './promptParser';
import { logger } from '../utils/logger';

/**
 * Generate the backend code based on the user's prompt
 */
export async function generateBackend(
  prompt: string,
  config: GeneratorConfig = {}
): Promise<GenerationResult> {
  try {
    logger.log('Generating backend from prompt:', prompt);
    logger.log('Using model:', config.model || 'default model');

    // Parse the prompt to determine what needs to be generated
    const parsedPrompt = await parsePrompt(prompt, config);

    if (!parsedPrompt.success) {
      return {
        success: false,
        error: parsedPrompt.error || 'Failed to parse prompt'
      };
    }

    // Generate a unique ID for this backend
    const backendId = nanoid(10);

    // Create the basic backend structure
    const backend: GeneratedBackend = {
      name: parsedPrompt.data?.name || `generated-backend-${backendId}`,
      description: parsedPrompt.data?.description || 'Generated backend from user prompt',
      version: '0.1.0',
      nodes: [],
      workflows: [],
      endpoints: []
    };

    // Generate nodes
    if (parsedPrompt.data?.nodes) {
      for (const nodeInfo of parsedPrompt.data.nodes) {
        const node = await generateNodeCode(nodeInfo, config);
        if (node) {
          backend.nodes.push(node);
        }
      }
    }

    // Generate workflows and their endpoints
    if (parsedPrompt.data?.workflows) {
      for (const workflowInfo of parsedPrompt.data.workflows) {
        const workflow = await generateWorkflowCode(workflowInfo, config);
        if (workflow) {
          backend.workflows.push(workflow);
          // Add endpoints from this workflow
          if (workflow.endpoints) {
            workflow.endpoints.forEach(endpoint => {
              backend.endpoints.push(endpoint);
            });
          }
        }
      }
    }

    // Generate OpenAPI specification
    const openApiSpec = generateOpenAPISpec(backend);
    saveOpenApiSpec(openApiSpec);

    // Save the backend data
    updateGeneratedBackend(backend);

    // Write all the generated files
    await writeGeneratedFiles(backend, config);

    return {
      success: true,
      data: backend
    };
  } catch (error) {
    logger.error('Error generating backend:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Write all the generated files to disk
 */
async function writeGeneratedFiles(
  backend: GeneratedBackend,
  config: GeneratorConfig
): Promise<void> {
  const outputDir = path.resolve(process.cwd(), config.outputDir || './src');

  // Create directories if they don't exist
  const nodesDir = path.join(outputDir, 'nodes');
  const workflowsDir = path.join(outputDir, 'workflows');

  if (!fs.existsSync(nodesDir)) {
    fs.mkdirSync(nodesDir, { recursive: true });
  }

  if (!fs.existsSync(workflowsDir)) {
    fs.mkdirSync(workflowsDir, { recursive: true });
  }

  // Write node files
  for (const node of backend.nodes) {
    const nodePath = path.join(outputDir, node.filepath);
    fs.writeFileSync(nodePath, node.code, 'utf8');
    logger.log(`Generated node file: ${nodePath}`);
  }

  // Write workflow files
  for (const workflow of backend.workflows) {
    const workflowPath = path.join(outputDir, workflow.filepath);
    // Get the workflow code (should be generated in the workflowGenerator)
    if (workflow.steps) {
      fs.writeFileSync(workflowPath, getWorkflowFileContent(workflow), 'utf8');
      logger.log(`Generated workflow file: ${workflowPath}`);
    }
  }
}

/**
 * Get the workflow file content
 */
function getWorkflowFileContent(workflow: GeneratedWorkflow): string {
  // This is just a placeholder - the actual workflow code should be 
  // generated in the workflowGenerator
  return `/**
 * Generated workflow: ${workflow.name}
 * Description: ${workflow.description || 'No description provided'}
 * Endpoints: ${workflow.endpoints.map(e => `${e.method} ${e.path}`).join(', ')}
 * Generated by Generative Backend Builder
 */

import { type Step, Workflow } from "@nanoservice-ts/helper";

// ${workflow.description}
const step: Step = Workflow({
  name: "${workflow.name}",
  version: "0.1.0",
  description: "${workflow.description}",
})
  .addTrigger("http", {
    method: "${workflow.endpoints[0]?.method || 'GET'}",
    path: "${workflow.endpoints[0]?.path || '/'}",
    accept: "application/json",
  })
  // Additional steps will be defined by the workflowGenerator
  
export default step;`;
}

/**
 * Save the OpenAPI specification to a file
 */
function saveOpenApiSpec(spec: OpenAPISpec): void {
  try {
    const docsDir = path.join(process.cwd(), 'src', 'generator');
    if (!fs.existsSync(docsDir)) {
      fs.mkdirSync(docsDir, { recursive: true });
    }

    fs.writeFileSync(
      path.join(docsDir, 'swagger.json'),
      JSON.stringify(spec, null, 2),
      'utf8'
    );

    logger.log('Generated OpenAPI specification');
  } catch (error) {
    logger.error('Error saving OpenAPI specification:', error);
  }
} 