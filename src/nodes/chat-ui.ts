/**
 * Generated node: ChatUI
 * Description: A real-time chat interface using WebSockets and EJS templates
 * Type: ui
 * Generated by Generative Backend Builder
 */

import fs from "node:fs";
import path from "node:path";
import { type INanoServiceResponse, NanoService, NanoServiceResponse } from "@nanoservice-ts/runner";
import { type Context, GlobalError } from "@nanoservice-ts/shared";
import ejs from "ejs";

const rootDir = path.resolve(__dirname, ".");
const templateName = "chat.ejs";
const templateContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .messages-container {
            height: 60vh;
            overflow-y: auto;
        }
        .dark-theme {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .light-theme {
            background-color: #f3f4f6;
            color: #000000;
        }
        .message {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 8px;
            max-width: 70%;
        }
        .user-message {
            background-color: #3b82f6;
            color: white;
            margin-left: auto;
        }
        .other-message {
            background-color: #e5e7eb;
            color: #1f2937;
        }
    </style>
</head>
<body class="<%= theme === 'dark' ? 'dark-theme' : 'light-theme' %> flex flex-col min-h-screen">
    <header class="py-4 px-6 shadow-md">
        <h1 class="text-2xl font-bold"><%= title %></h1>
    </header>
    
    <main class="flex-grow p-6">
        <div id="messages" class="messages-container mb-4"></div>
        
        <div class="flex gap-2">
            <input type="text" id="messageInput" 
                class="flex-grow p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" 
                placeholder="Type your message...">
            <button id="sendButton" 
                class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Send
            </button>
        </div>
    </main>

    <script>
        // Store user data
        const username = prompt('Enter your username:') || 'User_' + Math.floor(Math.random() * 1000);
        
        // Connect to WebSocket
        const socket = new WebSocket(\`\${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//<%= websocketHost %>/ws\`);
        
        socket.onopen = () => {
            addSystemMessage('Connected to chat server');
            // Send join message
            socket.send(JSON.stringify({
                type: 'join',
                username: username
            }));
        };
        
        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            if (data.type === 'message') {
                addMessage(data.username, data.text, data.username === username);
            } else if (data.type === 'system') {
                addSystemMessage(data.text);
            }
        };
        
        socket.onclose = () => {
            addSystemMessage('Disconnected from chat server');
        };
        
        // UI Functions
        function addMessage(username, text, isUser) {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = \`message \${isUser ? 'user-message' : 'other-message'}\`;
            
            const usernameSpan = document.createElement('div');
            usernameSpan.className = 'font-bold text-sm';
            usernameSpan.textContent = username;
            
            const textSpan = document.createElement('div');
            textSpan.textContent = text;
            
            messageEl.appendChild(usernameSpan);
            messageEl.appendChild(textSpan);
            messagesDiv.appendChild(messageEl);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'text-center text-gray-500 text-sm my-2';
            messageEl.textContent = text;
            messagesDiv.appendChild(messageEl);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Event Listeners
        document.getElementById('sendButton').addEventListener('click', sendMessage);
        document.getElementById('messageInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message) {
                // Send to server
                socket.send(JSON.stringify({
                    type: 'message',
                    username: username,
                    text: message
                }));
                
                // Clear input
                input.value = '';
            }
        }
    </script>
</body>
</html>`;

type InputType = {
  title: string;
  theme?: 'light' | 'dark';
};

export default class ChatUI extends NanoService<InputType> {
  constructor() {
    super();

    // Set the input schema for validation
    this.inputSchema = {
      type: "object",
      properties: {
        title: { type: "string" },
        theme: { type: "string", enum: ["light", "dark"] }
      },
      required: ["title"]
    };

    // Set the output schema
    this.outputSchema = {
      type: "object",
      properties: {
        html: { type: "string" }
      }
    };

    // Set html content type
    this.contentType = "text/html";

    // Create the template file if it doesn't exist
    this.createTemplateFile();
  }

  /**
   * Create the EJS template file if it doesn't exist
   */
  private createTemplateFile(): void {
    try {
      const templatePath = path.resolve(rootDir, templateName);
      if (!fs.existsSync(templatePath)) {
        fs.writeFileSync(templatePath, templateContent, 'utf8');
      }
    } catch (error) {
      console.error('Error creating template file:', error);
    }
  }

  /**
   * Relative path to root
   */
  root(relPath: string): string {
    return path.resolve(rootDir, relPath);
  }

  async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse> {
    // Create a new instance of the response
    const response = new NanoServiceResponse();

    const title = inputs.title;
    const theme = inputs.theme || 'light';

    try {
      // Get the template path
      const templatePath = this.root(templateName);

      // Read the template file
      const content = fs.existsSync(templatePath)
        ? fs.readFileSync(templatePath, 'utf8')
        : templateContent;

      // Compile the EJS template
      const render = ejs.compile(content, { client: false });

      // Get the hostname for the WebSocket connection
      const host = ctx.request.headers.host || 'localhost:4000';

      // Render the HTML
      const html = render({
        title,
        theme,
        websocketHost: host
      });

      // Set the response
      response.setSuccess(html);
    } catch (error: unknown) {
      const nodeError: GlobalError = new GlobalError((error as Error).message);
      nodeError.setCode(500);
      nodeError.setStack((error as Error).stack);
      nodeError.setName(this.name);
      response.setError(nodeError);
    }

    return response;
  }
} 