/**
 * Generated node: WebSocketHandler
 * Description: Handles WebSocket connections for the chat application
 * Type: websocket
 * Generated by Generative Backend Builder
 */

import { type INanoServiceResponse, NanoService, NanoServiceResponse } from "@nanoservice-ts/runner";
import { type Context, GlobalError } from "@nanoservice-ts/shared";
import WebSocket from 'ws';

// Store active WebSocket connections
const activeConnections: Map<string, {
  socket: WebSocket;
  username: string;
}> = new Map();

type InputType = {
  action: 'connect' | 'message' | 'disconnect';
  socketId?: string;
  message?: {
    type: string;
    username: string;
    text?: string;
  };
};

export default class WebSocketHandler extends NanoService<InputType> {
  constructor() {
    super();

    // Set the input schema for validation
    this.inputSchema = {
      type: "object",
      properties: {
        action: { type: "string", enum: ["connect", "message", "disconnect"] },
        socketId: { type: "string" },
        message: {
          type: "object",
          properties: {
            type: { type: "string" },
            username: { type: "string" },
            text: { type: "string" }
          }
        }
      },
      required: ["action"]
    };

    // Set the output schema
    this.outputSchema = {
      type: "object",
      properties: {
        success: { type: "boolean" },
        message: { type: "string" }
      }
    };
  }

  async handle(ctx: Context, inputs: InputType): Promise<INanoServiceResponse> {
    // Create a new instance of the response
    const response = new NanoServiceResponse();

    try {
      switch (inputs.action) {
        case 'connect':
          // New connection - should be handled by the server
          response.setSuccess({
            success: true,
            message: 'WebSocket connection established'
          });
          break;

        case 'message':
          if (!inputs.socketId || !inputs.message) {
            throw new Error('Missing required parameters for message action');
          }

          const message = inputs.message;

          if (message.type === 'join') {
            // User joined the chat
            if (ctx.request.socket && ctx.request.socket instanceof WebSocket) {
              activeConnections.set(inputs.socketId, {
                socket: ctx.request.socket,
                username: message.username
              });

              // Broadcast to all clients that a new user joined
              this.broadcast({
                type: 'system',
                text: `${message.username} joined the chat`
              });
            }
          } else if (message.type === 'message') {
            // Regular chat message - broadcast to all clients
            this.broadcast({
              type: 'message',
              username: message.username,
              text: message.text
            });
          }

          response.setSuccess({
            success: true,
            message: 'Message processed'
          });
          break;

        case 'disconnect':
          if (!inputs.socketId) {
            throw new Error('Missing socketId for disconnect action');
          }

          const connection = activeConnections.get(inputs.socketId);
          if (connection) {
            // Broadcast that the user left
            this.broadcast({
              type: 'system',
              text: `${connection.username} left the chat`
            });

            // Remove from active connections
            activeConnections.delete(inputs.socketId);
          }

          response.setSuccess({
            success: true,
            message: 'WebSocket disconnected'
          });
          break;

        default:
          throw new Error(`Invalid action: ${inputs.action}`);
      }
    } catch (error: unknown) {
      const nodeError: GlobalError = new GlobalError((error as Error).message);
      nodeError.setCode(500);
      nodeError.setStack((error as Error).stack);
      nodeError.setName(this.name);
      response.setError(nodeError);
    }

    return response;
  }

  /**
   * Broadcast a message to all connected clients
   */
  private broadcast(message: any): void {
    const messageString = JSON.stringify(message);

    activeConnections.forEach(({ socket }) => {
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(messageString);
      }
    });
  }
} 